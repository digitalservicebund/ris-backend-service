# 25. define domain exceptions handling

Date: 2026-02-04

## Status

Proposed

## Context

We want to handle our domain exceptions in a centralized way that is establishing rules for how our exceptions are defined and what data they carry. This should also make handling of our exceptions easier since they will follow a pattern where all exceptions relay data uniformly.
Another benefit of this approach is that in the controller there are no more try-catch blocks that need to be covered by tests and that reduce readability.


The idea is simply that since all HTTP exceptions fall into well known categories (400, 401, 403, 404, 500, etc.) one or more of our domain exceptions should be mapped to these categories.
By defining a common interface for all of our domain exceptions we ensure:
- uniform representation of every error
- handlers that are easier to read (example below)
- easier mapping of data

### RFC-9457 — Problem Details for HTTP APIs (summary)

RFC-9457 defines a standardized JSON structure to convey machine-readable and human-readable error information in HTTP responses. Core members to include:

- `type` — A URI reference that identifies the problem type. When dereferenced it may provide human-readable documentation.
- `title` — Short, human-readable summary of the problem type.
- `status` — The HTTP status code generated by the origin server for this occurrence.
- `detail` — Human-readable explanation specific to this occurrence of the problem.
- `instance` — A URI reference that identifies the specific occurrence of the problem.

RFC-9457 allows extension members: include domain-specific keys inside the same object (for example `error_code`, `invalid_fields`, `trace_id`) to provide more structured context.

[RFC-9457](https://www.rfc-editor.org/rfc/rfc9457.html)

### Guidelines

This ADR references and builds upon the following ADRs:
- [RIS-NORMS- 11. How to use exceptions in the backend](https://github.com/digitalservicebund/ris-norms/blob/main/doc/adr/0011-concept-exception-handling-backend.md)
- [RIS-NORMS - 12. Error responses](https://github.com/digitalservicebund/ris-norms/blob/main/doc/adr/0012-error-responses.md)
- [14. Concept for handling REST API errors](https://github.com/digitalservicebund/ris-backend-service/blob/main/doc/adr/0014-error-handling-concept.md)


## Current state

Project already uses @ControllerAdvice annotation to handle exceptions. The setup at this moment is to define a handler for each domain exception.
The example below is from our code:
```java
@ExceptionHandler({ImportApiKeyException.class})
public ResponseEntity<Object> handleImportApiKeyException(ImportApiKeyException ex) {
  ApiError apiError = new ApiError(HttpStatus.BAD_REQUEST, ex.getMessage());
  return new ResponseEntity<>(apiError, new HttpHeaders(), HttpStatus.BAD_REQUEST);
}

@ExceptionHandler({LdmlTransformationException.class})
public ResponseEntity<Object> handleLdmlTransformationException(LdmlTransformationException ex) {
  ApiError apiError = new ApiError(HttpStatus.BAD_REQUEST, ex.getMessage());
  return new ResponseEntity<>(apiError, new HttpHeaders(), HttpStatus.BAD_REQUEST);
}
```

## Proposed state

### Backend

Common interface that every domain exception implements:
```java
interface CaselawException() {
  /**
   * The type of exception starting with `/error/`
   */
  URI getType();

  /**
   * Short, human-readable summary of the problem type.
   */
  String getTitle();

  /**
   * Human-readable explanation specific to this occurrence of the problem.
   */
  String getDetail();

  /**
   * Additional details about the exception that could be sent to the user.
   * See "Extension Members" in RFC-9457
   */
  Map<String, Object> getProperties();
}
```

***NOTE** - `getProperties` could also be a `Map<String, String>` because then we do not need to worry about serializing objects into JSON. Also Frontend would not need additional logic to handle different `Objects`. If there would be a specific need where we could not provide whole information `Object` could be introduced.

The above interface would ensure we could write handlers in the following way:

```java
@ExceptionHandler({
    ImportApiKeyException.class,
    LdmlTransformationException.class
})
public ResponseEntity<ErrorDTO> handleAsBadRequest(CaselawException ex) {
  return ResponseEntity
      .badRequest()
      .body(Mapper.mapToErrorDto(ex))
      .build();
}
```

This way every system interacting with ours can know that we always deliver errors in the same standardized format, and they don't need to introduce more complexity than necessary.

This approach would allow a global error handler to be defined in `main.ts` and then all errors, potentially, could be handled in one place because we know the error payload is always the same.

### Suggestions for refactoring

Due to tech debt always being a tough topic to negotiate time for in almost every project this approach requires somewhat more effort in the beginning, but still a relatively small effort, by implementing:
- interface
- error DTO
- mapper for the above

And alongside this, if project time and schedule allows, we can refactor only one of the domain exceptions to adhere to the new style and also write a handler with the correct naming for this refactored exception.
Then everyone can at any later stage, whenever they have time or the task they work on is touching the domain exception that is not refactored can include in their work a refactor.
This way refactoring can really be done in small incremental steps.

## Decision

Decided to be accepted and the first PR inpmlementing this new way should cover one of the more complex refactoring cases.

## Consequences

- our Frontend will need to adapt and possibly recognise the format of the error and then handle it accordingly since we will still have two possible return formats.
- improved readability
- faster implementation of a new domain exception
- developer doesn't need to think much about what data to provide as interface is suggesting that
- potentially faster decision on how to handle the exception
